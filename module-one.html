<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="./style.css" />
  </head>
  <body>
    <main>
      <h1>EngX Bootcamp 2.0 <a href="./index.html">back ></a></h1>
      <br />

      <h2>The EngX Culture</h2>
      <p>
        Engineering Excellence standards and practices combined with each
        engineer’s behavior and communication form an Agile-infused Engineering
        Excellence (EngX) culture. This culture supports every aspect of a
        software development project and team and facilitates successful product
        delivery.
      </p>
      <p>
        Стандарты и практики инженерного мастерства в сочетании с поведением и
        общением каждого инженера формируют культуру инженерного мастерства
        (EngX), основанную на Agile. Эта культура поддерживает каждый аспект
        проекта разработки программного обеспечения и команды и способствует
        успешному выпуску продукта.
      </p>

      <ul>
        <li>
          Сосредоточьтесь на выполнении рабочих задач с наивысшим приоритетом
          для бизнеса в сложной среде, что снижает рабочий стресс.
        </li>
        <li>
          Разрабатывайте новые функции вместо выполнения повторяющихся ручных
          задач, таких как регрессионное тестирование или развертывание.
        </li>
        <li>
          Сократите количество дефектов и доработок с помощью более быстрых
          циклов обратной связи
        </li>
      </ul>

      <ul>
        <li>
          Культура EngX обеспечивает безопасную среду, в которой все члены
          команды четко понимают цели и план проекта, что гарантирует, что они
          сосредоточатся на текущих приоритетах и ​​получат значимые результаты.
        </li>
        <li>
          Гибкое лидерство жизненно важно для создания культуры EngX. Лидеры
          должны быть гибкими; создать атмосферу доверия, расширения прав и
          возможностей, сотрудничества; и поддерживать инфраструктуру, которая
          помогает командам добиваться инженерного совершенства. Лидеры также
          должны признавать вклад каждого члена команды и создавать атмосферу, в
          которой инженеры стремятся делиться своим опытом и учиться друг у
          друга.
        </li>
        <li>
          В культуре EngX Agile-команды применяют лучшие инженерные практики,
          чтобы подойти к жизненному циклу разработки программного обеспечения
          таким образом, чтобы повысить гибкость бизнеса клиента и время выхода
          на рынок, сохраняя при этом качество продукта. Оптимальное сочетание
          практик, процессов и инструментов Agile позволяет инженерам
          автоматизировать все повторяющиеся задачи и сосредоточиться на
          создании ценности на протяжении всего проекта. Такой подход повышает
          креативность и производительность, что приводит к более высокой
          степени удовлетворенности клиентов.
        </li>
        <li>
          В культуре инженерного мастерства все — и команды, и клиенты —
          соглашаются с четким и недвусмысленным «Определением готовности».
          Чтобы определить, можно ли считать конкретную задачу выполненной,
          необходимо проверить ее по установленному списку индикаторов. Инженеры
          обычно несут ответственность за создание этого списка с технической
          точки зрения. Однако этот процесс также требует консультаций с
          клиентами и сохранения прозрачности, чтобы избежать недоразумений в
          будущем. Помечая каждую новую функцию или выпуск как выполненные, ваша
          команда может обеспечить постоянное качество и полноту кода, что
          упрощает отслеживание хода проекта.
        </li>
      </ul>

      <hr />

      <h2>Basic SDLC</h2>

      <p>
        A typical SDLC is comprised of six phases: Requirements, Design,
        Software Development, Testing, User Acceptance Testing (UAT)/Staging,
        and Maintenance.
      </p>

      <h2>End-to-end</h2>
      <p>
        Сквозное тестирование, оно же End-to-end или E2E, — это процесс
        тестирования, при котором происходит подробная эмуляция пользовательской
        среды. То есть при данном тестировании имитируют:
      </p>
      <ul>
        <li>щелчки мышью,</li>
        <li>нажатия на кнопки,</li>
        <li>заполнение форм,</li>
        <li>переходы по страницам и ссылкам,</li>
        <li>и другие поведенческие факторы.</li>
      </ul>
      <p>
        Суть этого тестирования — посмотреть, так ли работает программа для
        конечного клиента, как рассчитывалось изначально? При этом нужно
        учитывать, что пользователю все равно, функционирует ли программа «как
        надо», ему главное, чтобы программа функционировала и оправдывала
        ожидания, поэтому основной упор делается на корректное функционирование.
      </p>
      <p>
        Е2Е-процесс — это конечный этап тестирования, после него никакого
        тестирования не проводят. Он самый трудозатратный и дорогой, именно
        поэтому находится на вершине пирамиды тестирования.
      </p>
      <p>
        <a href="End-to-end"
          >https://codernet.ru/articles/drugoe/end-to-end_ili_e2e-proczess_chto_eto_skvoznoe_testirovanie/</a
        >
      </p>
      <hr />
      <h2>Unit Testing</h2>
      <p>
        Модульный тест проверяет функциональность мельчайших тестируемых
        элементов приложения — классов и функций — что позволяет разработчикам
        обнаружить сбой и изолировать его.
      </p>
      <p>
        В отличие от многих других типов тестирования, модульные тесты должны
        быть написаны и обновлены теми же разработчиками, которые пишут и
        корректируют код приложения.
      </p>
      <p>Модульные тесты должны быть написаны одновременно с основным кодом.</p>
      <p>
        Запуск всего набора модульных тестов занимает несколько секунд, что
        позволяет вашей команде регулярно выполнять тестирование.
      </p>
      <p>Модульный тест НЕ требует запуска приложения.</p>

      <h3>Principles of Good Unit Testing</h3>
      <ul>
        <li>
          <h4>Fast</h4>
          <p>
            Тесты должны выполняться быстро. Весь набор модульных тестов должен
            выполняться за секунды. Чем быстрее тесты, тем больше их может быть
            в наборе и тем чаще вы сможете их запускать.
          </p>
        </li>
        <li>
          <h4>Independent</h4>
          <p>
            Тесты не должны зависеть друг от друга. Один тест не должен задавать
            условия для следующего. Члены вашей команды должны иметь возможность
            запускать каждый тест независимо и в любом порядке. Когда тесты
            зависят друг от друга, первый неудачный вызовет каскад последующих
            отказов, что усложнит диагностику и скроет последующие дефекты.
          </p>
        </li>
        <li>
          <h4>Repeatable</h4>
          <p>
            Тесты должны повторяться в любой среде. Если модульные тесты
            проходят успешно при выполнении один за другим, но терпят неудачу
            при выполнении всего набора тестов, это недостаток дизайна.
          </p>
        </li>
        <li>
          <h4>Self-Validating</h4>
          <p>
            Тесты должны иметь логический вывод и либо пройти, либо не пройти.
            Тот же самый тест, который не проходит сейчас и проходит позже,
            ненадежен и ставит под угрозу весь набор тестов.
          </p>
        </li>
        <li>
          <h4>Timely</h4>
          <p>
            Модульные тесты должны быть написаны своевременно — до или
            одновременно с производственным кодом. Тестирование постфактум
            требует от разработчиков в вашей команде рефакторинга рабочего кода
            и дополнительных усилий, чтобы тесты соответствовали принципам
            FIRST.
          </p>
        </li>
      </ul>

      <h3>Other Attributes of Good Unit Tests</h3>
      <ul>
        <li>
          <h4>Maintainable</h4>
          <p>
            Сопровождаемость означает, что код модульного тестирования считается
            таким же важным, как и производственный код. Если вы хотите, чтобы
            производственный код вашей команды было легко поддерживать, вы также
            должны сделать так, чтобы ваши модульные тесты были простыми в
            обслуживании.
          </p>
        </li>
        <li>
          <h4>Isolated</h4>
          <p>
            Хороший модульный тест должен быть изолирован от любых внешних
            зависимостей (например, базы данных, файловой системы, настроек
            среды, сети). Когда вы задействуете эти внешние системы, ваши
            «модульные» тесты могут провалиться по причинам, связанным с
            окружающей средой, которые не имеют ничего общего с вашим
            производственным кодом.
          </p>
        </li>
        <li>
          <h4>Properly Targeted</h4>
          <p>
            Успешный набор тестов нацелен только на основные части рабочей
            кодовой базы проекта. По этой причине важно отличать сердцевину
            приложения — модель предметной области — от всего остального. На
            основе реализованной логики производственный код подразделяется на
            три типа.
          </p>
          <ol>
            <li>
              <b>Practically Unit-Testable</b>
              Основные функции: бизнес-расчеты, алгоритмы, повторно используемый
              (платформенный) код и т. д.
            </li>
            <li>
              <b>Unit-Testable in Theory</b>
              <ul>
                <li>
                  Нестабильный код: элементы управления/стили пользовательского
                  интерфейса или нестабильный код прототипа (POC);
                </li>
                <li>
                  Сложные для написания модульные тесты: многопоточный код,
                  самозагрузка приложений, автогенерируемый код и т.д.
                </li>
              </ul>
            </li>
            <li>
              <b>Intentionally Unit-Untestable</b>
              <ul>
                <li>Взаимодействие с внешними зависимостями</li>
                <li>Шаблон и тривиальный код</li>
              </ul>
            </li>
          </ol>
        </li>
      </ul>

      <hr />

      <h2>Code Coverage</h2>
      <p>
        Покрытие кода — это простая метрика, часто используемая для поиска
        частей кодовой базы, в которых нет модульных тестов.
      </p>
      <blockquote>
        <b
          >Code Coverage = Lines of code executed / Total number of code
          lines</b
        >
      </blockquote>
      <ul>
        <li>
          покрытие операторов — каждая ли строка исходного кода была
          выполнена и протестирована;
        </li>
        <li>
          покрытие условий — каждая ли точка решения (вычисления
          истинно ли или ложно выражение) была выполнена и протестирована;
        </li>
        <li>
          покрытие путей — все ли возможные пути через заданную
          часть кода были выполнены и протестированы;
        </li>
        <li>
          покрытие функций — каждая ли функция программы была
          выполнена;
        </li>
        <li>
          покрытие вход/выход — все ли вызовы функций и возвраты из
          них были выполнены.
        </li>
        <li>
          покрытие значений параметров — все ли типовые и граничные
          значения параметров были проверены.
        </li>
      </ul>
      <p>
        Покрытие кода рассчитывается как отношение между количеством строк кода,
        выполненных во время модульного теста, и общим количеством строк в коде.
        Другими словами, он сообщает, сколько кода выполняется во время
        выполнения набора тестов.
      </p>
      <p>
        Несмотря на то, что Покрытие кода обеспечивает ценную обратную связь,
        покрытие кода нельзя использовать в качестве эффективной меры качества
        модульного теста.
      </p>

      <h3>Code Coverage Advantages</h3>
      <p>
        Метрики покрытия кода могут быть полезны для отслеживания
        высокоуровневой тенденции проекта по модульному тестированию (например,
        покрытие кода всего пакета не должно уменьшаться).
      </p>
      <p>
        Это также может помочь вашей команде определить области проекта, в
        которых нет модульных тестов.
      </p>

      <h3>Code Coverage Limitations</h3>
      <p>
        Покрытие кода не дает никакого представления о том, какой код
        тестируется, или о качестве выполненных тестов. Крайним примером
        является набор тестов без единого утверждения, который может иметь
        покрытие кода более 99%. Использование такого набора тестов — пустая
        трата времени, поскольку он просто выполняет код, а не тестирует его.
      </p>
      <hr />
      <script src="./index.js"></script>
    </main>
  </body>
</html>

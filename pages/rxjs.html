<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RxJS</title>
    <link rel="stylesheet" href="../styles/style.css" />
  </head>
  <body>
    <main>
      <h1>RxJS<a href="../index.html">back ></a></h1>

      <h2>Observable</h2>
      <h3>What is a data stream</h3>
      <p>
        Поток - это данные, которые прибывают в течение определенного периода
        времени. Поток данных может быть чем угодно.
      </p>
      <p>
        Следующая диаграмма показывает, как значения поступают в течение
        определенного периода времени. Как вы можете видеть, Stream излучает
        значения асинхронно.
      </p>
      <p>
        <img
          src="https://www.tektutorialshub.com/wp-content/uploads/2020/01/mouse-click-events-as-data-streams.jpg"
        />
      </p>
      <p>
        Значение - это не единственное, что излучает поток. Поток может
        завершаться, когда пользователь закрывает окно или приложение. Или может
        произойти ошибка, которая приводит к закрытию потока. В любой момент
        времени поток может излучать любую из следующих трех вещей
      </p>
      <ol>
        <li><code>Value</code>: i.e the next value in the stream</li>
        <li><code>Complete</code>: The stream has ended</li>
        <li><code>Error</code>: The error has stopped the stream.</li>
      </ol>
      <p>Поток данных может быть чем угодно</p>
      <ol>
        <li>Mouse event</li>
        <li>Keyboard events</li>
        <li>Form events like value changes etc</li>
        <li>Data which arrives after an HTTP request</li>
        <li>User Notifications</li>
        <li>Measurements from any sensor</li>
      </ol>
      <p>Важные моменты, касающиеся потоков, они могут:</p>
      <ol>
        <li>Излучать ноль, одно или несколько значений любого времени.</li>
        <li>Может излучать ошибки.</li>
        <li>
          Должен излучать полный сигнал, когда завершается (конечные потоки).
        </li>
        <li>Может быть бесконечным</li>
      </ol>
      <h3>What is RxJS</h3>
      <p>RXJS позволяет нам работать с асинхронными потоками данных</p>
      <p>
        Angular использует библиотеку RXJS в своей структуре для реализации
        реактивного программирования.
      </p>
      <ol>
        <li>Реагирование на HTTP-запрос в Angular</li>
        <li>Изменениях значений / состояния в Angular формах</li>
        <li>
          Модули маршрутизатора и форм используют Observable для прослушивания и
          реагирования на события
        </li>
        <li>
          Пользовательские события, которые отправляют Observable выходные
          данные от ребенка в родительский компонент
        </li>
        <li>Модуль HTTP использует Observable для обработки запросов</li>
      </ol>
      <p>The RxJs has two main players</p>
      <ol>
        <li>Observable</li>
        <li>Observers ( Subscribers)</li>
      </ol>
      <h3>What is an Observable in Angular</h3>
      <p>
        <code>Observable</code> - это функция, которая преобразует обычный поток
        данных в наблюдаемый поток данных. Вы можете думать о
        <code>Observable</code>, как о обертке вокруг обычного потока данных.
      </p>
      <p>
        <code>Observable</code> излучает значение из потока асинхронно. Он
        возвращает complete, когда поток завершается, или error, если поток
        вернул ошибку.
      </p>
      <p>
        <code>Observable</code> декларативны. Вы определяете
        <code>Observable</code>, как и любая другая переменная.
        <code>Observable</code> начинает выделять значения только тогда, когда
        кто -то подписывается на него.
      </p>
      <h3>Who are observers (subscribers)</h3>
      <p>
        <code>Observable</code> бесполезен, пока кто-то не поддпишется на него.
        Мы называем их <code>observers</code> или <code>subscribers</code>.
      </p>
      <p>
        <code>Observers</code> общаются с <code>Observable</code>, используя
        обратные вызовы
      </p>
      <p>
        <code>Observer</code> должен подписаться на <code>Observable</code>,
        чтобы получить значение от <code>Observable</code>. При подписке на него
        проходит три обратного вызова: <code>next()</code>,
        <code>error()</code> & <code>complete()</code>.
      </p>
      <p>
        <code>Observable</code> начинает издавать значение, как только
        наблюдатель или потребитель подписываются на него.
      </p>
      <ol>
        <li>Observers/subscribers subscribe to Observables</li>
        <li>
          Observer registers three callbacks with the observable at the time of
          subscribing. i .e next(), error() & complete()
        </li>
        <li>All three callbacks are optional</li>
        <li>
          The observer receives the data from the observer via the next()
          callback
        </li>
        <li>
          They also receive the errors and completion events from the Observable
          via the error() & complete() callbacks
        </li>
      </ol>
      <pre>
        public obs = new Observable((observer) => {
          console.log("Observable starts")
          observer.next("1")
          observer.next("2")
          observer.next("3")
          observer.error(new Error())
          observer.complete()
        });

        ngOnInit() {
          this.obs.subscribe(
            val => { console.log(val) },
            error => { console.log("error") },
            () => { console.log("Completed") }
          )
        }

        ngOnDestroy() {
          this.obs.unsubscribe();
        }
      </pre>
      <h3>Unsubscribing from an Observable</h3>
      <p>
        Нам нужно отписаться, чтобы закрыть Observable, когда он больше не
        требуется. Иначе, это может привести к утечке памяти и деградации
        производительности.
      </p>
      <pre>
        ngOnDestroy() {
          this.obs.unsubscribe();
        }
      </pre>

      <h2>Subject</h2>
      <p>
        Subject - это особый тип Observable, который позволяет значениям быть
        многоадресными для многих наблюдателей. Subject также являются
        наблюдателями, потому что они могут подписаться на другого Observable и
        получить от него значения, которая будет адресованы для всех его
        подписчиков.
      </p>
      <p>По сути, Subject может действовать как Observable, так и Observer.</p>
      <h3>How does Subjects work</h3>
      <p>
        Субъекты реализуют как метод subscribe(), так и next, error & complete
        методы. Он также поддерживает коллекцию observers[]
      </p>
      <p>
        <img
          src="https://www.tektutorialshub.com/wp-content/uploads/2021/04/Angular-Subjects.png"
        />
      </p>
      <p>
        Observer может подписаться на Subject и получать от него значения.
        Subject добавляет их в свою коллекцию observers[]. Всякий раз, когда в
        потоке есть значение, он уведомляет всех его наблюдателей.
      </p>
      <h3>Creating a Subject in Angular</h3>
      <pre>
        subject$ = new Subject();
 
        ngOnInit() {
          this.subject$.subscribe(val => {
            console.log(val);
          });
      
          this.subject$.next("1");
          this.subject$.next("2");
          // this.subject$.error("error")
          this.subject$.complete();
        }
      </pre>
      <h3>Subject is hot Observable</h3>
      <p>Observables are classified into two groups. Cold & Hot</p>
      <h4>Cold observable</h4>
      <p>
        Cold observable не активирует выдачу данных, пока не появится подписчик.
        Обычно это тот случай, когда сам наблюдаемая производит данные.
      </p>
      <p>
        Производитель производит значение только тогда, когда подписчик
        подписывается на него.
      </p>
      <h4>Hot observable</h4>
      <p>
        Hot observable не ждет подписчика чтобы начать выдачу данных. Он может
        начать излучать значения сразу. Это происходит, когда производитель
        находится за пределами observable.
      </p>
      <h3>Every Subject is an Observer</h3>
      <pre>
        subject$ = new Subject();
 
        observable = new Observable(observer => {
          observer.next("first");
          observer.next("second");
          observer.error("error");
        });
      
        ngOnInit() {
          this.subject$.subscribe(val => {
            console.log(val);
          });
      
          this.observable.subscribe(this.subject$);
        }
      </pre>
      <h3>Subjects are Multicast</h3>
      <p>
        Более одного подписчика может подписаться на Subject. Все подписчики
        получают одно и то же значение, когда Subject его излучает.
      </p>
      <p>
        Несколько наблюдателей Observable, с другой стороны, получат отдельный
        экземпляр Observables.
      </p>
      <h3>BehaviorSubject</h3>
      <p>
        <code>BehaviorSubject</code> требует начальное значение, хранит текущее
        значение и отправляет его новым подписчикам.
      </p>
      <pre>
        const sbj = new BehaviorSubject&lt;number&gt;(5);

        sbj.subscribe((vl) => console.log(`1st: ${vl}`));
        sbj.subscribe((vl) => console.log(`2nd: ${vl}`));
        sbj.next(7);

        // Log:
        1st: 5
        2nd: 5
        1st: 7
        2nd: 7
      </pre>
      <h3>ReplaySubject</h3>
      <p>
        В отличие от <code>BehaviorSubject</code> объекты
        <code>ReplaySubject</code> способны хранить заданное количество
        последних значений, которое задается при создании объекта.
      </p>
      <p>
        Все новые "потребители" сразу же получают по очереди все n указанных
        значений RxJS ReplaySubject.
      </p>
      <pre>
        const sbj = new ReplaySubject(2);

        sbj.next(5);
        sbj.subscribe((vl) => console.log(`1st: ${vl}`));
        sbj.next(6);
        sbj.next(7);
        sbj.subscribe((vl) => console.log(`2nd: ${vl}`));
        
        // Log:
        1st: 5
        1st: 6
        1st: 7
        2nd: 6
        2nd: 7
      </pre>
      <h3>AsyncSubject</h3>
      <p>
        В случае с <code>AsyncSubject</code> "потребителям" передается только
        последнее значение объекта и только, когда он завершит свое выполнение
        (вызов <code>complete()</code>).
      </p>
      <pre>
        const sbj = new AsyncSubject();

        sbj.subscribe((vl) => console.log(`Async: ${vl}`));
        sbj.next(7);
        sbj.next(8);
        sbj.next(9);
        setTimeout(() => sbj.complete(), 3000);

        // Log:
        Async: 9
      </pre>
      <hr />

      <h2>Scheduler</h2>
      <p>
        Для управления временем и очередностью выполнения операций в объектах
        Observable, имеются RxJS Schedulers.
      </p>
      <p>Имеются следующие типы RxJS Schedulers:</p>
      <ul>
        <li><code>queue</code> - добавляет операцию в callstack;</li>
        <li><code>asap</code> - регистрирует операцию в очереди микрозадач;</li>
        <li>
          <code>async</code> - регистрирует операцию в очереди макрозадач;
        </li>
        <li>
          <code>animationFrame</code> - отвечает за действия, выполняемые перед
          перерисовкой.
        </li>
      </ul>
      <p>
        В качестве второго необязательного параметра большинству операторов
        можно передать объект RxJS <code>Scheduler</code>, который
        переопределяет поведение оператора по умолчанию.
      </p>
      <p>
        Сама библиотека RxJS написана таким образом, что разработчику
        практически никогда не приходится менять стандартное поведение
        Observable, задаваемое операторами совместно с <code>Scheduler</code>.
      </p>
      <h3>observeOn()</h3>
      <p>
        Для управления передачей данных, в <code>pipe()</code> используйте метод
        <code>observeOn()</code>. Он принимает <code>Scheduler</code> и
        определяет, в каком порядке "потребители" получат данные после их
        отправления.
      </p>
      <pre>
        console.log('Before');

        of(9)
          .pipe(observeOn(async))
          .subscribe((vl) => console.log('Value is: ', vl));

        console.log('After');
      </pre>
      <h3>subscribeOn()</h3>
      <p>
        В отличие от <code>observeOn()</code>, метод
        <code>subscribeOn()</code> определяет не контекст передачи данных, а
        контекст вызова метода <code>subscribe()</code>. Параметром ему также
        передается Scheduler.
      </p>
      <pre>
        console.log('Before');

        of(9)
          .pipe(subscribeOn(async))
          .subscribe((vl) => console.log('Value is: ', vl));

        console.log('After');
      </pre>
      <hr />

      <h2>From Operator</h2>
      <p>
        <code>From</code> принимает только один перебираемый аргумент, и
        преобразует его в Observable.
      </p>
      <ol>
        <li>an Array,</li>
        <li>anything that behaves like an array</li>
        <li>Promise</li>
        <li>any iterable object</li>
        <li>collections</li>
        <li>any observable like object</li>
      </ol>
      <p>
        <img
          src="https://www.tektutorialshub.com/wp-content/uploads/2020/01/Observable-from-Operator.jpg"
        />
      </p>
      <pre>
        ngOnInit() {
            const array = [1, 2, 3]
            const obsfrom = from(array);
            obsfrom.subscribe(val => console.log(val))
        }
        
        *** Output ****
        1
        2
        3
      </pre>

      <hr />

      <h2>FromEvent</h2>
      <p>
        Angular предоставляет метод <code>fromEvent</code> для непосредственного
        создания Observable из событий DOM.
      </p>
      <h3>Syntax</h3>
      <pre>
        fromEvent&lt;T&gt;(
          target: fromEventTarget&lt;T&gt;, 
          eventName: string, 
          options: EventListenerOptions, 
          resultSelector: (...args: any[]) => T): Observable&lt;T&gt;
        )
      </pre>
      <p>
        <code>FromEventTarget</code> - это первый аргумент
        <code>fromEvent</code>. Это может быть DOM EventTarget, Node.js
        EventEmitter, JQuery-подобная цель события, NodeList или HTMLCollection.
        Цель должна иметь метод для регистрации/отмены регистрации обработчика
        событий. (addEventListener/removeEventListener в случае цели события
        DOM)
      </p>
      <p>
        <code>eventName</code> - это второй аргумент, который представляет собой
        тип события, которое мы хотим прослушать.
      </p>
      <p>
        <code>Options</code> - это дополнительный аргумент, который мы хотим
        передать при регистрации обработчика событий, т. е.
        <code>addEventListener</code>.
      </p>
      <p>
        <code>resultSelector</code> является необязательным и будет объявлен
        устаревшим в будущих версиях.
      </p>
      <h3>How it works</h3>
      <p>
        Когда мы подписываемся на наблюдаемый объект, который мы создали с
        помощью метода <code>fromEvent</code>, он регистрирует обработчик
        события с помощью <code>addEventListener</code> в элементе DOM. Всякий
        раз, когда пользователь нажимает кнопку,
        <code>fromEvent</code> фиксирует значение и передает его подписчику в
        качестве первого аргумента. Когда мы отменяем подписку, он отменяет
        регистрацию обработчика событий, используя метод
        <code>removeEventListener</code>.
      </p>
      <hr />

      <h2>Of Operator</h2>
      <p>
        <code>Of</code> создает Observable из аргументов, которые вы ему
        передаете. Вы можете передать любое количество аргументов в
        <code>Of</code>. Каждый аргумент выдается отдельно и один за другим. В
        конце он посылает сигнал Complete.
      </p>
      <p>
        <img
          src="https://www.tektutorialshub.com/wp-content/uploads/2020/01/Observable-Of-Operator.jpg"
        />
      </p>
      <pre>
        ngOnInit() {
          const obs = of(1, 2, 3);
          obs.subscribe(val => console.log(val))
        }

        **** Output ***
        1
        2
        3
      </pre>
      <hr />

      <h2>ThrowError</h2>
      <p>
        Оператор Angular ThrowError возвращает Observable, который при подписке
        сразу же выдает ошибку. Он не выдает никаких результатов.
      </p>
      <h3>Throw Error Vs ThrowError</h3>
      <p>
        <code>Throw Error</code> выдает ошибку. Это конструкция JavaScript и не
        является частью RxJs. Нам нужно использовать блок
        <code>try/catch</code> для перехвата ошибок, вызванных
        <code>Throw Error</code>. RxJS использует блок
        <code>try/catch</code> для перехвата любых ошибок, выдаваемых
        наблюдаемыми объектами. И когда они ловят один, они выдают уведомление
        об ошибке (вызывают обратный вызов ошибки), а затем Observable
        останавливается.
      </p>
      <p>
        <code>ThrowError</code> не выдает такие ошибки, как
        <code>throw Error</code>. Он возвращает новую Observable, которая выдает
        уведомление об ошибке (вызывает обратный вызов ошибки), а затем
        останавливается.
      </p>
      <h3>Using ThrowError</h3>
      <p>
        Чтобы выдавать уведомление об ошибке, необходимо подписаться на
        <code>throwError</code>. Мы можем использовать его для компоновки с
        другими <code>Observables</code>, такими как <code>mergeMap</code>,
        <code>switchMap</code>, <code>catchError</code> и т. д.
      </p>
      <hr />

      <h2>CombineLatest</h2>
      <p>
        Объединяет несколько Observables для создания Observable, значения
        которого рассчитываются на основе последних значений каждого из его
        входных Observables.
      </p>
      <pre>
        combineLatest(observables: ...Observable, project: function): Observable
      </pre>
      <p>
        <b>
          Имейте в виду, что combineLatest не будет выдавать начальное значение,
          пока каждый наблюдаемый объект не выдаст хотя бы одно значение.
        </b>
      </p>
      <p>
        <img
          src="https://rxjs.dev/assets/images/marble-diagrams/combineLatest.png"
        />
      </p>
      <p>
        <code>combineLatest</code> объединяет значения из всех Observables,
        переданных в массив observables. Это делается путем подписки на каждый
        Observable по порядку и всякий раз, когда какой-либо Observable излучает
        значение, собирается массив самых последних значений из каждого
        Observable.
      </p>
      <pre>
        const firstTimer = timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
        const secondTimer = timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now

        const combinedTimers = combineLatest([firstTimer, secondTimer]);

        combinedTimers.subscribe(value => console.log(value));

        // Logs
        // [0, 0] after 0.5s
        // [1, 0] after 1s
        // [1, 1] after 1.5s
        // [2, 1] after 2s
      </pre>
      <p>
        Статическая версия <code>combineLatest</code> принимает массив
        <code>Observables</code>. Обратите внимание, что массив
        <code>Observables</code> - хороший выбор, если вы заранее не знаете,
        сколько <code>Observables</code> вы будете комбинировать. Передача
        пустого массива приведет к немедленному завершению
        <code>Observable</code>.
      </p>
      <p>
        Чтобы гарантировать, что выходной массив всегда имеет одинаковую длину,
        combineLatest фактически будет ждать, пока все входные
        <code>Observable</code> будут выданы хотя бы один раз, прежде чем он
        начнет выдавать результаты. Это означает, что если некоторые
        <code>Observable</code> излучают значения до того, как другие
        <code>Observable</code> начали излучать, все эти значения, кроме
        последнего, будут потеряны.
      </p>
      <p>
        С другой стороны, если какой-то <code>Observable</code> не испускает
        значение, но завершается, результирующий
        <code>Observable</code> завершится в тот же момент, ничего не испуская,
        поскольку теперь будет невозможно включить значение из завершенного
        <code>Observable</code> в результирующий массив. Кроме того, если
        некоторый входной <code>Observable</code> не выдает никакого значения и
        никогда не завершается, <code>combineLatest</code> также никогда не
        выдает и никогда не завершается, так как, опять же, он будет ждать, пока
        все потоки выдадут какое-то значение.
      </p>
      <p>
        Если хотя бы один <code>Observable</code> был передан в
        <code>combineLatest</code>, и все переданные Observable что-то
        испустили, результирующий Observable завершится, когда завершатся все
        объединенные потоки. Таким образом, даже если какой-либо Observable
        завершится, результат <code>combineLatest</code> все равно будет
        выдавать значения, когда это сделают другие <code>Observable</code>. В
        случае завершенного <code>Observable</code> его значение с этого момента
        всегда будет последним переданным значением.
      </p>
      <p>
        С другой стороны, если какие-либо <code>Observable</code> ошибки,
        <code>combineLatest</code> также немедленно выдаст ошибку, и все
        остальные <code>Observable</code> будут отписаны.
      </p>
      <hr />

      <h2>WithLatestFrom</h2>
      <p>
        Объединяет исходный Observable с другими Observable для создания нового
        Observable, значения которого рассчитываются на основе последних
        значений каждого исходного Observable, только когда исходный Observable
        излучает значения.
      </p>
      <pre>
        withLatestFrom(other: Observable, project: Function): Observable
      </pre>
      <p>
        <img
          src="https://rxjs.dev/assets/images/marble-diagrams/withLatestFrom.png"
        />
      </p>
      <p>
        Всякий раз, когда исходный Observable выдает значение, он вычисляет
        формулу, используя это значение плюс последние значения из других
        входных Observable, а затем выдает результат этой формулы.
      </p>
      <pre>
        const source = interval(5000);
        const secondSource = interval(1000);

        source
          .pipe(withLatestFrom(secondSource))
          .subscribe((val) => console.log(val));
        
        // Logs
        // [0, 4] after 5s
        // [1, 9] after 10s
        // [2, 14] after 15s
      </pre>
      <hr />

      <h2>Buffer</h2>
      <p>
        Собирает значения из прошлого в виде массива и испускает этот массив
        только тогда, когда испускается другой Observable.
      </p>
      <p>
        <img src="https://rxjs.dev/assets/images/marble-diagrams/buffer.png" />
      </p>
      <p>
        Буферизирует входящие значения Observable до тех пор, пока данный
        Observable ClosingNotifier не выдаст значение, после чего он выдаст
        буфер на выходе Observable и запустит новый внутренний буфер, ожидая
        следующего выброса CloseNotifier.
      </p>
      <pre>
        import { fromEvent, interval, buffer } from 'rxjs';

        const clicks = fromEvent(document, 'click');
        const intervalEvents = interval(1000);
        const buffered = intervalEvents.pipe(buffer(clicks));
        buffered.subscribe(x => console.log(x));
      </pre>
      <hr />

      <h2>Map</h2>
      <p>
        Применяет заданную функцию проекта к каждому значению, испускаемому
        исходным Observable, и выдает результирующие значения как Observable.
      </p>
      <p>
        <img src="https://rxjs.dev/assets/images/marble-diagrams/map.png" />
      </p>
      <pre>
        import { fromEvent, map } from 'rxjs';

        const clicks = fromEvent&lt;PointerEvent&gt;(document, 'click');
        const positions = clicks.pipe(map(ev => ev.clientX));

        positions.subscribe(x => console.log(x));
      </pre>
      <hr />

      <h2>Filter</h2>
      <pre>
        filter(select: Function, thisArg: any): Observable
      </pre>
      <p>
        Подобно известному методу Array.prototype.filter, этот оператор берет
        значения из исходного Observable, передает их через функцию-предикат и
        выдает только те значения, которые дали true.
      </p>
      <p>
        <img src="https://rxjs.dev/assets/images/marble-diagrams/filter.png" />
      </p>
      <pre>
        const source = from([1, 2, 3, 4, 5]);
        const example = source.pipe(filter(num => num % 2 === 0));
        const subscribe = example.subscribe(val => console.log(val));

        //output: 2, 4
      </pre>
      <hr />
      <h2>Debounce</h2>
      <pre>
        debounce(durationSelector: function): Observable
      </pre>
      <p>
        debounce отслеживает самое последнее значение и выдает это самое
        последнее значение, используя наблюдаемую продолжительность в качестве
        индикатора того, где это сделать
      </p>
      <p>Оператор работает следующим образом:</p>
      <ol>
        <li>
          когда появится новое значение, выполните функцию, чтобы получить
          Observable продолжительности
        </li>
        <li>подписаться на Observable продолжительности</li>
        <li>сохранить значение и отбросить старые, если они существуют</li>
        <li>
          когда Observable продолжительности испускает значение или завершается,
          передать сохраненное значение наблюдателю
        </li>
        <li>
          если новое значение приходит до того, как продолжительность Observable
          испускает или завершает, снова запустите шаг 1
        </li>
      </ol>
      <p>
        Этот оператор в основном используется для событий, которые могут
        запускаться десятки или даже сотни раз в секунду. Наиболее
        распространенными примерами являются события DOM, такие как прокрутка,
        движение мыши и нажатие клавиши. При использовании debouce вас
        интересует только конечное состояние. Например, текущая позиция
        прокрутки, когда пользователь прекращает прокрутку, или окончательный
        текст в поле поиска после того, как пользователь перестает вводить
        символы. По сути, использование оператора позволяет сгруппировать
        несколько последовательных событий в одно и, следовательно, выполнить
        обратный вызов только один раз. Это может значительно улучшить
        производительность.
      </p>
      <pre>
        const clicks = fromEvent(document, 'click');
        const result = clicks.pipe(
          scan((i) => ++i, 1),
          debounce((i) => interval(200 * i))
        );
        result.subscribe((x) => console.log(x));
      </pre>
      <hr />

      <h2>DebounceTime</h2>
      <pre>
        debounceTime(dueTime: number, scheduler: Scheduler): Observable
      </pre>
      <p>
        Этот оператор отслеживает самое последнее уведомление от исходного
        Observable и выдает его только тогда, когда должное время прошло без
        каких-либо других уведомлений, появляющихся в исходном Observable.
      </p>
      <p>
        <img
          src="https://rxjs.dev/assets/images/marble-diagrams/debounceTime.png"
        />
      </p>
      <p>
        Если новое значение появится до наступления тишины dueTime, предыдущее
        уведомление будет удалено и не будет отправлено, а запланировано новое
        dueTime.
      </p>
      <p>
        Если событие завершения происходит во время dueTime, последнее
        кэшированное уведомление выдается до того, как событие завершения будет
        перенаправлено в выходной наблюдаемый объект.
      </p>
      <p>
        Если событие ошибки происходит во время dueTime или после него, только
        событие ошибки перенаправляется в выходной наблюдаемый объект.
        Уведомление кэша в этом случае не выдается.
      </p>
      <pre>
        import { fromEvent, debounceTime } from 'rxjs';

        const clicks = fromEvent(document, 'click');
        const result = clicks.pipe(debounceTime(1000));
        result.subscribe(x => console.log(x));
      </pre>
      <hr />

      <h2>DistinctuntilChanged</h2>
      <pre>
        distinctUntilChanged(
          comparator?: (previous: K, current: K) => boolean,
          keySelector: (value: T) => K = identity as (value: T) => K
        ): Observable
      </pre>
      <h3>Parameters</h3>
      <p>
        <code>comparator</code> - Optional. Default is undefined. Функция,
        используемая для сравнения предыдущего и текущего ключей на равенство.
        По умолчанию используется проверка ===.
      </p>
      <p>
        <code>keySelector</code> - Optional. Используется для выбора значения
        ключа, которое будет передано в компаратор.
      </p>
      <h3>Description</h3>
      <p>
        При передаче без параметров или с первым параметром
        (<code>comparator</code>) он ведет себя следующим образом:
      </p>
      <ol>
        <li>Он всегда будет выдавать первое значение из источника.</li>
        <li>
          Для всех последующих значений, переданных источником, они будут
          сравниваться с ранее переданными значениями с использованием
          предоставленного компаратора или проверки на равенство ===.
        </li>
        <li>
          Если значение, переданное источником, определяется этой проверкой как
          неравное, это значение выдается и становится новым «ранее выданным
          значением» внутри.
        </li>
      </ol>
      <p>
        Когда указан второй параметр (<code>keySelector</code>), поведение
        меняется:
      </p>
      <ol>
        <li>Он всегда будет выдавать первое значение из источника.</li>
        <li>
          KeySelector будет выполняться для всех значений, включая первое
          значение.
        </li>
        <li>
          Для всех значений после первого выбранный ключ будет сравниваться с
          ключом, выбранным из ранее выданного значения, с помощью компаратора.
        </li>
        <li>
          Если эта проверка определяет, что ключи не равны, выдается значение
          (не ключ), и выбранный ключ из этого значения сохраняется для будущих
          сравнений с другими ключами.
        </li>
      </ol>
      <pre>
        const totallyDifferentBuilds$ = of(
          { engineVersion: '1.1.0', transmissionVersion: '1.2.0' },
          { engineVersion: '1.1.0', transmissionVersion: '1.4.0' },
          { engineVersion: '1.3.0', transmissionVersion: '1.4.0' },
          { engineVersion: '1.3.0', transmissionVersion: '1.5.0' },
          { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }
        ).pipe(
          distinctUntilChanged((prev, curr) => {
            return (
              prev.engineVersion === curr.engineVersion ||
              prev.transmissionVersion === curr.transmissionVersion
            );
          })
        );
        
        totallyDifferentBuilds$.subscribe(console.log);
        
        // Logs:
        // { engineVersion: '1.1.0', transmissionVersion: '1.2.0' }
        // { engineVersion: '1.3.0', transmissionVersion: '1.4.0' }
        // { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }
      </pre>
      <hr />

      <h2>Skip</h2>
      <pre>
        skip(the: Number): Observable
      </pre>
      <p>
        <img src="https://rxjs.dev/assets/images/marble-diagrams/skip.png" />
      </p>
      <p>
        <code>skip</code> озволяет игнорировать первые x значений из источника.
        Обычно пропуск используется, когда у вас есть Observable, которое всегда
        выдает определенные значения при подписке, которые вы хотите
        игнорировать.
      </p>
      <pre>
        const source = interval(500);
        const result = source.pipe(skip(10));

        result.subscribe(value => console.log(value));
        // output: 10...11...12...13...
      </pre>
      <hr />

      <h2>Take</h2>
      <pre>
        take(count: number): Observable
      </pre>
      <p>
        <img src="https://rxjs.dev/assets/images/marble-diagrams/take.png" />
      </p>
      <p>
        <code>take</code> возвращает Observable, который выдает только первые
        значения счетчика, испускаемые исходным Observable. Если источник выдает
        меньше значений, чем count, то выдаются все его значения. После этого он
        завершается, независимо от того, завершается ли источник.
      </p>
      <pre>
        const intervalCount = interval(1000);
        const takeFive = intervalCount.pipe(take(5));
        takeFive.subscribe(x => console.log(x));

        // output: 0...1...2...3...4
      </pre>
      <hr />

      <h2>Share</h2>
      <p>
        Возвращает новый Observable, который выполняет многоадресную рассылку
        (совместно использует) исходный Observable. Пока есть хотя бы один
        подписчик, этот Observable будет подписан и будет выдавать данные. Когда
        все подписчики отпишутся, он отпишется от исходного Observable.
        Поскольку Observable является многоадресным, это делает поток горячим.
      </p>
      <p>
        <img src="https://rxjs.dev/assets/images/marble-diagrams/share.png" />
      </p>
      <p>
        Подписка на базовый исходный Observable может быть сброшена, если
        количество подписчиков на общий наблюдаемый объект падает до 0 или если
        исходный Observable ошибается или завершается.
      </p>
      <pre>
        const source = interval(1000).pipe(
          tap(x => console.log('Processing: ', x)),
          map(x => x * x),
          take(6),
          share()
        );
        
        source.subscribe(x => console.log('subscription 1: ', x));
        source.subscribe(x => console.log('subscription 2: ', x));

        // Logs:
        // Processing: 0
        // subscription 1: 0
        // subscription 2: 0
        ...
        // Processing: 5
        // subscription 1: 25
        // subscription 2: 25
      </pre>
      <hr />

      <h2>Tap</h2>
      <pre>
        tap(nextOrObserver: function, error: function, complete: function): Observable
      </pre>
      <p>
        <img src="https://rxjs.dev/assets/images/marble-diagrams/tap.png" />
      </p>
      <p>
        Функция, которая возвращает Observable, идентичный источнику, но
        запускает указанный Observer или обратный вызов для каждого элемента.
      </p>
      <hr />

      <h2>Delay</h2>
      <pre>
        delay(delay: number | Date, scheduler: Scheduler): Observable
      </pre>
      <p>
        <img
          src="https://rxjs.dev/assets/images/marble-diagrams/delay.svg"
          width="100%"
        />
      </p>
      <p>Сдвигает каждый элемент на определенное количество миллисекунд.</p>
      <p>
        Если аргумент задержки является числом, время этого оператора сдвигает
        исходный Observable на это количество времени, выраженное в
        миллисекундах. Относительные интервалы времени между значениями
        сохраняются.
      </p>
      <p>
        Если аргумент задержки является датой, время этого оператора сдвигает
        начало выполнения Observable до тех пор, пока не наступит заданная дата.
      </p>
      <pre>
        const clicks = fromEvent(document, 'click');
        const delayedClicks = clicks.pipe(delay(1000)); // each click emitted after 1 second
        delayedClicks.subscribe(x => console.log(x));
      </pre>
      <hr />

      <h2>Timeout</h2>
      <pre>
        timeout(due: number, scheduler: Scheduler): Observable
      </pre>
      <p>
        <img src="https://rxjs.dev/assets/images/marble-diagrams/timeout.png" />
      </p>
      <p>
        Возвращает Observable, которая выдаст ошибку, если источник не передаст
        значение в течение указанного времени в миллисекундах. Функционально это
        то же самое, что и timeout({ each: milliseconds })).
      </p>
      <hr />

      <h2>Find</h2>
      <pre>
        find(predicate: function)
      </pre>
      <p>
        <img src="https://rxjs.dev/assets/images/marble-diagrams/find.png" />
      </p>
      <p>
        <code>find</code> ищет первый элемент в исходном Observable, который
        соответствует указанному условию, воплощенному предикатом, и возвращает
        первое вхождение в источнике. В отличие от <code>first</code>, предикат
        требуется в <code>find</code> и не выдает ошибку, если допустимое
        значение не найдено (вместо этого выдает undefined).
      </p>
      <hr />

      <h2>Every</h2>
      <pre>
        every(predicate: function, thisArg: any): Observable
      </pre>
      <p>
        <img src="https://rxjs.dev/assets/images/marble-diagrams/every.png" />
      </p>
      <p>
        Если все значения соответствуют условию до завершения источника, перед
        завершением выдается true, в противном случае выдается false, затем
        завершается.
      </p>
      <pre>
        of(1, 2, 3, 4, 5, 6)
          .pipe(every(x => x < 5))
          .subscribe(x => console.log(x)); // -> false
      </pre>
      <hr />

      <h2>ConcatMap</h2>
      <pre>
        concatMap(project: function, resultSelector: function): Observable
      </pre>
      <p>
        <b> Функция <code>project</code> должна возвращать Observable!!!</b>
      </p>
      <p>
        <img
          src="https://rxjs.dev/assets/images/marble-diagrams/concatMap.png"
        />
      </p>
      <p>
        <code>ConcatMap</code> сопоставляет каждое значение из исходного
        Observable с внутренним Observable, подписывается на внутренний
        Observable, а затем начинает выдавать значения из него, заменяя исходное
        значение.
      </p>
      <p>
        Он создает новый внутренний Observable для каждого значения, которое он
        получает от Источника. Он объединяет значения всех своих внутренних
        Observable в том порядке, в котором они подписаны, и отправляет значения
        обратно в поток.
      </p>
      <p>
        В отличие от <code>SwitchMap</code>, <code>ConcatMap</code>
        <b>не отменяет ни один из своих внутренних Observable</b>. Он похож на
        <code>MergeMap</code>, за исключением того, что он
        <b>поддерживает порядок своих внутренних Observable</b>.
      </p>
      <pre>
        const clicks = fromEvent(document, 'click');
        const result = clicks.pipe(
          concatMap((ev) => interval(1000).pipe(take(4)))
        ).subscribe((x) => console.log(x));

        // При каждом клике будут выдаваться значения от 0 до 3,
        // c интервалом в 1000ms
        // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
      </pre>
      <hr />

      <h2>SwitchMap</h2>
      <pre>
        switchMap(
          project: function: Observable, 
          resultSelector: function(outerValue, innerValue, outerIndex, innerIndex): any
        ): Observable
      </pre>
      <p>
        <b> Функция <code>project</code> должна возвращать Observable!!!</b>
      </p>
      <p>
        <img
          src="https://rxjs.dev/assets/images/marble-diagrams/switchMap.png"
        />
      </p>
      <p>
        SwitchMap сопоставляет каждое значение из исходного Observable с
        внутренним Observable, подписывается на внутренний Observable, а затем
        начинает излучать из него значения.
      </p>
      <p>
        Он создает новый внутренний Observable для каждого значения, которое он
        получает от Источника.
      </p>
      <p>
        Всякий раз, когда он создает новый внутренний Observable, он
        отписывается от всех ранее созданных внутренний Observable,
        <b>переключается на новейшие Observable, отбрасывая все остальные</b>.
      </p>
      <pre>
        fromEvent(document, 'click').pipe(
          switchMap(() => interval(1000)) // restart counter on every click
        ).subscribe(console.log);
      </pre>
      <hr />

      <h2>ExhaustMap</h2>
      <pre>
        exhaustMap(project: function, resultSelector: function): Observable
      </pre>
      <p>
        <b> Функция <code>project</code> должна возвращать Observable!!!</b>
      </p>
      <p>
        <img
          src="https://rxjs.dev/assets/images/marble-diagrams/exhaustMap.png"
        />
      </p>
      <p>
        <code><code>ExhaustMap</code></code> сопоставляет каждое значение из
        исходного Observable с внутренним Observable, подписывается на него.
        Затем он начинает излучать значения из него, заменяя исходное значение.
      </p>
      <p>
        Затем <code>ExhaustMap</code> ожидает завершения внутренней Observable.
        Если <code>ExhaustMap</code> получает какие-либо новые значения до
        завершения внутренней Observable, он игнорирует их.
      </p>
      <p>
        Как только <code>ExhaustMap</code> получает новое значение после
        завершения внутренней Observable, он создает новую внутреннюю
        Observable. Весь процесс повторяется до тех пор, пока исходная
        Observable не будет завершена.
      </p>

      <pre>
        // Запуск таймера для каждого клика
        // только если в данный момент нет активного таймера.
        
        const clicks = fromEvent(document, 'click');
        const result = clicks.pipe(
          exhaustMap(() => interval(1000).pipe(take(5)))
        );
        result.subscribe(x => console.log(x));
      </pre>
      <hr />

      <h2>MergeMap</h2>
      <pre>
        mergeMap(
          project: function: Observable, 
          resultSelector: function: any, 
          concurrent: number
        ): Observable
      </pre>
      <p>
        <b> Функция <code>project</code> должна возвращать Observable!!!</b>
      </p>
      <p>
        <img
          src="https://rxjs.dev/assets/images/marble-diagrams/mergeMap.png"
        />
      </p>
      <p>
        <code>MergeMap</code> сопоставляет каждое значение из Observable
        источника с внутренним Observable, подписывается на внутренний
        Observable, а затем начинает выдавать значения из него, заменяя исходное
        значение.
      </p>
      <p>
        <code>MergeMap</code> создает новую внутреннюю Observable для каждого
        значения, которое он получает от Источника.
      </p>
      <p>
        В отличие от <code>SwitchMap</code>, <code>MergeMap</code> не отменяет
        никаких внутренних Observable. <code>MergeMap</code> объединяет значения
        всех своих внутренних Observable и отправляет значения обратно в поток.
      </p>
      <hr />
    </main>

    <script src="../js/index.js"></script>
  </body>
</html>

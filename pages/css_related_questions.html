<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HTML Related Questions</title>
    <link rel="stylesheet" href="../styles/style.css" />
  </head>
  <body>
    <main>
      <h1>HTML Related Questions <a href="../index.html">back ></a></h1>

      <h2>1. Расшифровка css. Что значит каскад</h2>
      <p>
        CSS (Cascading Style Sheets, или каскадные таблицы стилей) - это
        декларативный язык, который отвечает за то, как страницы выглядят в веб
        браузере. CSS стили содержат свойства и их значения, которые и
        определяют, как будет выглядеть сайт.
      </p>
      <p>
        Каскад таблицы стилей, означает, что порядок следования правил в CSS
        имеет значение; когда применимы два правила, имеющие одинаковую
        специфичность, используется то, которое идёт в CSS последним.
      </p>

      <h2>2. Поток документа</h2>
      <p>
        В HTML формирование элементов на странице происходит сверху вниз. Слой,
        в верху кода, отобразится раньше слоя, в коде ниже. Такая логика
        позволяет прогнозировать результат вывода элементов и управлять им.
        Порядок вывода объектов на странице и называется «потоком».
      </p>

      <h2>
        3. Explain at least 2 ways to center modal window horizontally and
        vertically.
      </h2>
      <iframe
        src="https://css-tricks.com/centering-css-complete-guide/"
        width="100%"
        height="500"
      ></iframe>
      <p>
        <a href="https://css-tricks.com/centering-css-complete-guide/"
          >answer</a
        >
      </p>

      <h2>4. Describe best practices of writing CSS.</h2>
      <ul>
        <li>Код должен быть валидным (корректно выполняться).</li>
        <li>Комментарии должны быть подробными.</li>
        <li>
          Код должен быть разбит на логические блоки, каждый блок нужно отделять
          пустой строкой.
        </li>
        <li>Использование иерархии облегчает чтение кода.</li>
        <li>Свойства желательно размещать в алфавитном порядке.</li>
        <li>
          Каскадные таблицы <i>(CSS)</i> нужно размещать в отдельном файле.
        </li>
        <li>Неиспользуемые селекторы нужно удалять.</li>
        <li>Нужно использовать там, где возможно, универсальные свойства.</li>
      </ul>

      <h2>5. Разница между сбросом стилей и нормализацией</h2>
      <p>
        reset.css — как и видно по названию файла, сбрасывает большинство стилей
        браузера, которые в нем заданы по умолчанию
      </p>
      <p>
        normalize.css — этот файл не только задает стили по умолчанию там где
        это необходимо, но и исправляет некоторые недостатки старых браузеров
      </p>

      <h2>
        6. Каким образом вы боритесь с проблемами стилизации, связанными с
        кросс-браузерностью?
      </h2>
      <p>
        Есть несколько основных решений проблем стилизации, связанных с
        кросс-браузерностью.
      </p>
      <ul>
        <li>разделение стилей для разных браузеров и устройств</li>
        <li>добавление вендорных префиксов к стилевым правилам</li>
      </ul>
      <p>
        Метод разделения стилей заключается в идентификации вида браузера
        пользователя и применении соответствующего стиля совместно с основным,
        путем добавления условных комментариев (для IE) или CSS-хаков.
      </p>
      <p>
        С помощью правила @media можно указать тип устройства, для которого
        будет применены определенные стили, а добавление вендорных префиксов к
        стилям расширит список поддерживаемых браузеров.
      </p>
      <ul>
        <li>
          <a
            href="https://htmlacademy.ru/blog/boost/frontend/progressive-enhancement"
            >Прогрессивное улучшение
          </a>
        </li>
        <li>
          <a href="https://habr.com/ru/sandbox/22561/"
            >Кроссбраузерность. Причины и приемы
          </a>
        </li>
        <li>
          <a
            href="https://css-tricks.com/using-feature-detection-to-write-css-with-cross-browser-support/"
            >Using Feature Detection to Write CSS with Cross-Browser Support
          </a>
        </li>
      </ul>

      <h2>7. Fixed vs Adaptive design.</h2>
      <h3>Фиксированный дизайн</h3>
      <p>
        Самый популярный вариант вёрстки, при котором разрабатывается макет
        сайта фиксированной ширины
      </p>
      <ul>
        <li>Высокая скорость разработки сайта;</li>
        <li>Неудобство использования на мобильных устройствах;</li>
        <li>Небольшая стоимость разработки проекта;</li>
        <li>
          Устаревшая технология, прежде всего, по мнению поисковых систем;
        </li>
        <li>Простое и недорогое дальнейшее ведение;</li>
        <li>Неиспользуемые полосы по бокам на больших дисплеях;</li>
        <li>Поддержка и добавление новых страниц.</li>
      </ul>
      <h3>Адаптивный дизайн</h3>
      <p>
        Более сложный в исполнении вариант, при котором рисуется не один макет,
        а 3 макета различного разрешения. Наиболее часто используемая схема: 320
        | 768 | 1200. Таким образом, дизайнер вручную определяет, как будет
        смотреться сайт на всех возможных разрешениях.
      </p>
      <ul>
        <li>Лояльность со стороны поисковых систем;</li>
        <li>Удобное использование;</li>
        <li>
          Красивое отображение на всех типах устройств: от телефонов до ПК;
        </li>
        <li>Более высокая стоимость разработки;</li>
        <li>Длительный процесс разработки;</li>
        <li>Сложность дальнейшей доработки.</li>
      </ul>

      <h2>
        8. Alternative to flexbox and grid, how to make a template without them?
      </h2>
      <ol>
        <li>
          При <b>фиксированной</b> верстке размеры всех элементов страницы
          задаются фиксированными значениями.
        </li>
        <li>
          При <b>резиновой</b> верстке элементы всегда расширяются до полной
          ширины окна браузера, независимо от размера.
        </li>
        <li><b>Табличная верстка</b></li>
        <li><b>Верстка с div-блоками</b></li>
        <li>
          <b>Адаптивная</b> верстка. Фактически это та же блочная, только
          адекватно отображаемая на всех типах устройств.
        </li>
      </ol>

      <h2>9. Explain floating (Чем пользовались до флекса)</h2>
      <p>
        Определяет сторону, по которой будет выровнен элемент. Соседние элементы
        будут «обтекать» такой элемент по противоположной стороне.
      </p>
      <p>
        Отмена floating. Свойство clear, примененное к нижестоящему (от float)
        элементу со значениями left, right, both, а также свойство overflow со
        значением hidden.
      </p>

      <h2>10. Explain @media selector</h2>
      <p>
        Медиа-запросы позволяют адаптировать страницы для разных типов устройств
        (принтеров, речевых браузеров и т.д.) или для устройств с определенными
        характеристиками: ширина (width), высота (height), соотношение ширины к
        высоте области просмотра (aspect-ratio), ориентация (orientation),
        разрешение (resolution), количество бит на каждый из цветовых
        компонентов устройства (color) и другие.
      </p>
      <pre>
        <code>@media screen and (max-width: 600px)</code>
      </pre>

      <h2>11. Benefits of using preprocessors.</h2>
      <p>
        Преимущества использования препроцессоров: использование дополнительного
        функционала (переменных, Вложенность, условий, циклов, функций и т.д.).
      </p>

      <h2>12. Explain CSS Specificity.</h2>
      <p>
        Специфичность селектора (еще называют весом) это свойство определяющее
        приоритет стилевого правила, то есть то, какой стиль будет применен к
        HTML элементу в итоге.
      </p>
      <ul>
        <li>тег имеет специфичность 0001</li>
        <li>
          класс, а также псевдокласс и псевдоэлемент имеют специфичность 0010
        </li>
        <li>id имеет специфичностью 0100</li>
        <li>инлайновый стиль имеет приоритет 1000</li>
      </ul>

      <h2>13. Explain how z-index property works.</h2>
      <p>
        Определяет положение элемента по оси Z. Если элементы перекрываются друг
        другом (накладываются), это свойство диктует порядок наложения. Работает
        только для элементов у которых свойство position установлено как
        absolute/relative/fixed.
      </p>

      <h2>14. Explain when and how to use display: grid.</h2>
      <p>
        Чтобы создать Grid разметку, вам просто нужно выставить элементу
        <code>display: grid</code>
      </p>
      <pre>
        <code>#grid {</code>
        <code>display: grid;</code>
        <code>grid-template-rows: 1fr 1fr 1fr;</code>
        <code>grid-template-columns: 1fr 1fr 1fr;</code>
        <code>grid-gap: 2vw;</code>
        <code>}</code>
      </pre>
      <p>
        Вы так же можете использовать <code>display: inline-grid</code>, что
        создать строчный грид-контейнер.
      </p>
      <p>
        Вы можете использовать функцию <code>repeat()</code> для повторяющихся
        объявлений значения размера элемента.
      </p>
      <pre>
        <code>grid-template-rows: 1fr 1fr 1fr 1fr 1fr;</code>
        <code>grid-template-rows: repeat(5, 1fr);</code>
      </pre>

      <h2>15. Explain basics of flexbox layout.</h2>
      <h3>flex-grow</h3>
      <p>
        <img
          src="https://css-tricks.com/wp-content/uploads/2018/10/flex-grow.svg"
          alt=""
        />
      </p>
      <p>
        This defines the ability for a flex item to grow if necessary. Negative
        numbers are invalid.
      </p>
      <h3>flex-shrink</h3>
      <p>This defines the ability for a flex item to shrink if necessary.</p>
      <h3>flex-basis</h3>
      <p>
        This defines the default size of an element before the remaining space
        is distributed.
      </p>
      <h3>flex</h3>
      <p>
        This is the shorthand for flex-grow, flex-shrink and flex-basis
        combined. The second and third parameters (flex-shrink and flex-basis)
        are optional.
      </p>
      <pre><code>flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]</code></pre>

      <h2>16. Describe CSS Box Model.</h2>
      <p>
        В HTML-документе каждому элементу на странице соответствует
        прямоугольная область (бокс или блок)
      </p>
      <p>
        В CSS есть специальная блочная модель (англ. box model), которая
        описывает, из чего состоит бокс и какие свойства влияют на его размеры.
        В ней у каждого бокса есть 4 области:
      </p>
      <ol>
        <li>margin (внешние отступы)</li>
        <li>border (рамка)</li>
        <li>padding (внутренние поля)</li>
        <li>content (контент или содержимое)</li>
      </ol>

      <h2>17. List main CSS units.</h2>
      <dl>
        <dt><h3>Абсолютные единицы длины</h3></dt>
        <dd><code>px</code> - Pixels/Пиксели</dd>
        <dd><code>mm</code> - Millimeters/Миллиметры</dd>
      </dl>
      <dl>
        <dt><h3>Единицы относительной длины</h3></dt>
        <dd><code>em</code> - Размер шрифта родительского элемента.</dd>
        <dd><code>rem</code> - Размер шрифта корневого элемента.</dd>
        <dd><code>vw</code> - 1% от ширины окна просмотра.</dd>
        <dd><code>vh</code> - 1% от высоты окна просмотра.</dd>
        <dd>
          <code>vmin</code> - 1% от меньшего измерения ширины окна просмотра.
        </dd>
        <dd>
          <code>vmax</code> - 1% от большего измерения ширины окна просмотра.
        </dd>
      </dl>
      <dl>
        <dt>Проценты</dt>
      </dl>

      <h2>18. Explain margin collapsing.</h2>
      <p>
        Отступы margin-top и margin-bottom иногда объединяются в один, с
        размером равным наибольшему из них (или размеру одного, если они равны).
      </p>
      <p>
        Oтступы плавающих и абсолютно позиционированных элементов никогда не
        схлопываются.
      </p>
      <ul>
        <li>
          если у вас есть два элемента, отображающихся один за другим в
          нормальном потоке, нижний margin первого элемента будет схлопываться с
          верхним margin последующего элемента.
        </li>
        <li>
          верхнее поле родителя схлопнется с верхним полем своего потомка.
        </li>
        <li>
          Если блок пустой, его верхний и нижний margin могут схлопываться друг
          с другом
        </li>
      </ul>

      <h2>19. Block vs inline elements.</h2>
      <h3>Содержание</h3>
      <p>
        Как правило, блочные элементы могут содержать строчные элементы и другие
        блочные элементы. Неотъемлемой частью этого структурного различия
        является идея, что блочные элементы создают «более крупную» структуру,
        чем встроенные элементы.
      </p>
      <h3>Форматирование по умолчанию</h3>
      <p>
        По умолчанию блочные элементы начинаются с новой строки, а строчные
        могут начинаться в любом месте строки.
      </p>

      <h2>20. Pseudo classes and pseudo selectors. What the difference?</h2>
      <p>
        Псевдокласс — это селектор, который выбирает элементы, находящиеся в
        специфическом состоянии, например, они являются первым элементом своего
        типа, или на них наведён указатель мыши.
      </p>
      <ul>
        <li><code>:last-child</code></li>
        <li><code>:only-child</code></li>
        <li><code>:required</code></li>
        <li><code>:hover</code></li>
        <li><code>:focus</code></li>
      </ul>
      <p>
        Псевдоэлементы ведут себя сходным образом, однако они действуют так, как
        если бы вы добавили в разметку целый новый HTML-элемент, а не применили
        класс к существующим элементам. Псевдоэлементы начинаются с двойного
        двоеточия ::.
      </p>
      <ul>
        <li><code>::first-line</code></li>
        <li><code>::first-letter</code></li>
        <li><code>::after</code></li>
        <li><code>::before</code></li>
        <li><code>::selection</code></li>
      </ul>

      <h2>
        21. Какие анимации лучше всего обрабатываются браузом(оптимизированы).
        Как подготовить браузер к изменению (will change)
      </h2>
      <ul>
        <li>Анимация средствами CSS обычно обрабатывается отдельно от основного потока браузера. Aнимация, выполненная средствами CSS, потенциально может продолжать работать без прерывания. Изменение свойств <code>transform</code> и <code>opacity</code> во многих случаях может обрабатываться тем же потоком, что и анимация на основе CSS (этот поток называется потоком компоновщика), поэтому в идеале для анимации следует использовать именно эти свойства.</li>
        <li>Если какая-либо анимация вызывает перерисовку, перерасчет макета или и то, и другое, для нее потребуется основной поток.</li>
      </ul>
      <p>
        Рекомендуется использовать свойство will-change, чтобы передать в
        браузер информацию о том, что вы намерены изменить свойство элемента.
        Это позволяет браузеру предпринять наиболее подходящие шаги по
        оптимизации еще до того, как изменение будет выполнено.
      </p>

      <h2>22. Отношения между селекторами</h2>
      <ul>
        <li>
          родитель – элемент, непосредственно в котором находится элемент;
        </li>
        <li>
          предок – это элемент, на одном из уровней иерархии элементов, до
          которого можно дойти двигаясь от элемента к его родителю
        </li>
        <li>
          дети – это элементы, непосредственно расположенные в текущем элементе;
        </li>
        <li>
          потомки (дочерние элементы) – это элементы, которые находятся в
          текущем элементе вне зависимости от уровня иерархии;
        </li>
        <li>
          соседи – это элементы, расположенные на том же уровне вложенности
          (иерархии), что и элемент;
        </li>
      </ul>

      <h2>
        23. Самые известные вы наверняка знаете (отношения между селекторами):
      </h2>
      <p>Самые известные вы наверняка знаете:</p>
      <ul>
        <li>
          <code>div p</code> – элементы <code>p</code>, являющиеся потомками
          <code>div</code>.
        </li>
        <li><code>div > p</code> – только непосредственные потомки</li>
      </ul>
      <p>Есть и два более редких:</p>
      <ul>
        <li>
          <code>div ~ p</code> – правые соседи: все <code>p</code> на том же
          уровне вложенности, которые идут после <code>div</code>.
        </li>
        <li>
          <code>div + p</code> – первый правый сосед: <code>p</code> на том же
          уровне вложенности, который идёт сразу после <code>div</code> (если
          есть).
        </li>
      </ul>

      <h2>24. Все значения display</h2>
      <h3>none</h3>
      <p>Элемент не показывается, вообще. Как будто его и нет.</p>
      <h3>block</h3>
      <ul>
        <li>Блочные элементы располагаются один над другим, вертикально</li>
        <li>лок стремится расшириться на всю доступную ширину.</li>
      </ul>
      <h3>inline</h3>
      <ul>
        <li>Элементы располагаются на той же строке, последовательно.</li>
        <li>Ширина и высота элемента определяются по содержимому. Поменять их нельзя.</li>
      </ul>
      <h3>inline-block</h3>
      <ul>
        <li>Располагается в строке.</li>
        <li>Размер устанавливается по содержимому.</li>
        <li>Элемент всегда прямоугольный.</li>
        <li>Работают свойства width/height.</li>
      </ul>
      <h3>table-*</h3>
      <p>Современные браузеры (IE8+) позволяют описывать таблицу любыми элементами, если поставить им соответствующие значения display.</p>
      <h3>table-cell</h3>
      <p>Внутри ячеек свойство vertical-align выравнивает содержимое по вертикали.</p>
      <h3>list-item</h3>
      <p>Этот display по умолчанию используется для элементов списка.</p>
      <h3>run-in</h3>
      <p>Если после run-in идёт block, то run-in становится его первым инлайн-элементом, то есть отображается в начале block</p>
      <h3>flex-box</h3>
      <p>Flexbox позволяет удобно управлять дочерними и родительскими элементами на странице, располагая их в необходимом порядке.</p>

      <h2>25. Все значения position</h2>
      <div>
        <i>Relative</i> — положение элемента задается относительно исходного
        расположения. Сам элемент становится родительским для всех дочерних,
        абсолютно позиционировнных элементов.<br />
        <i>Fixed</i> — положение элемента привязывается к указанной свойствами
        left, top, right и bottom точке на экране и не меняет своего положения
        при прокрутке страницы.<br />
        <i>Absolute</i> — положение элемента задается относительно границ
        родительского элемента (тот у которого position: relative), элемент
        выпадает из изначального контекста.<br />
        <i>Static</i> — положение элемента остается неизменным. Такой вид
        позиционирования еще называют нормальным. Элементы отображаются в том же
        порядке, как они идут в исходном коде.
        <ul>
          <li>
            <a
              href="http://htmlbook.ru/samlayout/blochnaya-verstka/pozitsionirovanie-elementov"
              >Позиционирование элементов
            </a>
          </li>
          <li>
            <a href="https://webref.ru/course/position">Позиционирование </a>
          </li>
        </ul>
      </div>

      <h2>
        26. What BEM means? Main structure elements, rules, and difference
        between each other.
      </h2>
      <h3>Блок</h3>
      <p>Функционально независимый компонент страницы, который может быть повторно использован. В HTML блоки представлены атрибутом class.</p>
      <h4>Вложенность
      </h4>
      <ul>
        <li>Блоки можно вкладывать друг в друга.</li>
        <li>Допустима любая вложенность блоков.</li>
      </ul>
      <h3>Элемент</h3>
      <p>Составная часть блока, которая не может использоваться в отрыве от него.</p>
      <dl>
        <dt>Особенности:</dt>
        <dd>Название элемента характеризует смысл</dd>
        <dd>Структура полного имени элемента соответствует схеме: имя-блока__имя-элемента. Имя элемента отделяется от имени блока двумя подчеркиваниями (__).</dd>
      </dl>
      <h4>Вложенность</h4>
      <ul>
        <li>Элементы можно вкладывать друг в друга.</li>
        <li>Допустима любая вложенность элементов.</li>
        <li>Элемент — всегда часть блока, а не другого элемента. Это означает, что в названии элементов нельзя прописывать иерархию вида block__elem1__elem2.</li>
      </ul>
      <p>Элемент — всегда часть блока и не должен использоваться отдельно от него.</p>
      <p>Элемент — необязательный компонент блока. Не у всех блоков должны быть элементы.</p>
      <h3>Модификатор</h3>
      <p>Cущность, определяющая внешний вид, состояние или поведение блока либо элемента.</p>
      <dl>
        <dt>Особенности:</dt>
        <dd>Название модификатора характеризует внешний вид, состояние и поведение .</dd>
        <dd>Имя модификатора отделяется от имени блока или элемента одним подчеркиванием (_).</dd>
      </dl>
      <h4>Типы модификаторов</h4>
      <ul>
        <li>Булевый</li>
        <li>Ключ-значение - Используют, когда важно значение модификатора.</li>
        <li></li>
        <li></li>
      </ul>
      <p>! Модификатор нельзя использовать самостоятельно</p>
      <h3>Микс</h3>
      <p>Миксы позволяют:</p>
      <ul>
        <li>совмещать поведение и стили нескольких сущностей без дублирования кода;</li>
        <li>создавать семантически новые компоненты интерфейса на основе имеющихся.</li>
      </ul>

      <h2>27. Understanding the Critical Rendering Path</h2>
      <ul>
        <li>Constructing the DOM Tree</li>
        <li>Constructing the CSSOM Tree</li>
        <li>Running JavaScript</li>
        <li>Creating the Render Tree</li>
        <li>Generating the Layout</li>
        <li>Painting</li>
      </ul>
    </main>

    <script src="../js/index.js"></script>
  </body>
</html>
